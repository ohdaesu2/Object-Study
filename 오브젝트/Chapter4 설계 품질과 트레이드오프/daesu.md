Chapter4 설계 품질과 트레이드오프
=======================

### 객체 지향 설계
- 객체 지향 설계란 올바른 객체에게 올바른 책임을 하당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동
- 객체지향 설계의 핵심은 책임이다. 
  - 책임이 적절하게 할당되지 못한 상황에서는 좋은 협력을 기대할 수 없다.
  - 역할은 책임의 집합이기에, 이 또한 협력과 조화를 이루지 못한다. 
- 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관이 깊다. 

### 객제를 분할하는 방법
- 상태(data)와 책임, 2가지 관점으로 분할할 수 있다. 
- 상태의 관점으로 객체를 생성, 분할하면 변경에 어려움을 겪는다.
  - 객체의 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다. 
- 따라서 책임의 관점으로 봐야 한다! 
  - 객체의 책임은 인터페이스에 속한다. 
  - 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 

### 설계 트레이드오프
- 좋은 설계의 특징을 판단할 수 있는 기준에는 여러가지가 있다.
- 위의 두가지 분할에서 캡슐화, 응집도, 결합도의 관점에 따라 생각해보자.


### 캡슐화
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다.
- 변경될 가능성이 높은 부분을 구현, 상대적으로 안정적인 부분을 인터페이스라 부른다. 
- 즉, 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 미치지 않도록 하기 때문이다. 
- 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정한 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.
- 따라서 변경의 관점에서 설계의 품질을 판단하는 요소로 캡슐화를 사용할 수 있다.


### 응집도와 결합도
- 응집도
  - 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 
  - 모듈 내의 요소들이 하나의 목적을 위해 협력한다면 높은 응집도를, 서로 다른 목적을 추구한다면 낮은 응집도를 가진다.
- 결합도
  - 의존성의 정도를 나타내며 다른 모듈에 얼마나 많은 지식을 갖고 있는지를 나타내는 척도 
  - 어떤 모듈이 다른 모듈에 대해너무 자세하게 알고 있다면 높은 결합도를, 꼭 필요한 지식만 있다면 낮은 결합도를 가진다. 
- 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.
- 즉, 각 요소안의 목적은 같고 요소들 끼리는 느슨하게 결합돼 있다면 좋은 설계라고 말할 수 있다. 
- 좋은 설계는 변경과 관련된 것이기에, 설계의 품질을 결정하는 응집도와 결합도 또한 변경과 관련이 있다! 
- 변경의 관점에서 응집도란 ***변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도***로 측정할 수 있다.
- 변경의 관점에서 결합도란 ***한 모듈이 변경되기 위해서 다른모듈의 변경을 요구하는 정도***로 측정할 수 있다. 
- 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다. 따라서 캡슐화를 지키기 위해 항상 노력하자!!!

### 데이터 중심의 설계의 문제점
- 4장에서 구현한 데이터 중심의 영화 예매 시스템 설계는 책임 중심의 설계는 지켰지만, 데이터 중심으로 인해 캡슐화를 위반한다.
- 이 데이터 중심의 설계가 가진 대표적인 문제점을 다음과 같이 요약할 숭 ㅣㅆ다.
  1) 캡슐화 위반
  2) 높은 결합도
  3) 낮은 응집도

### 1. 캡슐화 위반
~~~
public class Movie{
  private Money fee;
  public Money getFee(){
    return fee;
  }
  public Money setFee(Money fee){
    this.fee = fee;
  }
}
~~~
- Movie안에 fee 값을 얻거나 수정하기 위해서는 getFee나 setFee method를 사용해야 한다. 
- 하지만, 접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다. 
- method 이름에서만 봐도 알 수 있듯이 Movie에 fee의 인스턴스 변수가 존재한다는 것을 노골적으로 드러낸다.
- 이는 데이터 중심의 설계를 진행했기 때문에 발생하는 문제점이다.


### 2. 높은 결합도
~~~
public class ReservationAgency {
  public Reservation reservation(Screening secreening, Customer customer, int audienceCount){
    ...
    Money fee;
    if (discountable){
      ...
      fee = movie.getFee().minus(discountAmount).times(audienceCount);
    } else{
      fee = movie.getFee();
    }
    ...
  }
}
~~~
- 만약에 Movie의 fee 타입을 수정하게 된다면 위에 있는 getFee() 또한 모두 수정해야 된다. 
- 대부분의 제어 로직을 가지고 있는 제어 객체인 ReservationAgency 가 모든 데이터 객체에 의존하고 있다.
- 이는 DiscountCondition, Screening 등 하나만 수정해도 ReservationAgency 또한 수정해야 함을 의미한다. 
- 데이터 중심의 설계가 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어버리는 결과를 초래한다. 


### 3. 낮은 응집도 
- ReservationAgency 안에 할인 정책을 선택하는 코드와 할인 조건을 판단하는 코드가 함께 존재한다.
- 따라서 새로운 할인 정책을 추가하는 작업이 생겼을 때, 할인 조건에도 영향을 미칠 수 있다. 
- 어떤 코드를 수정한 후에 아무런 상관도 없는 코드에 문제가 발생하는 것은 ***모듈의 응집도가 낮을 때 발생하는 대표적인 증상***이다.


### 캡슐화를 지키자
- 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다. 
- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다. 
- 여기서 메서드는 접근자나 수정자가 아닌 객체가 책임져야 하는 무언가를 수행하는 메서드다. 
- private로 설정했다 하더라도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 이는 캡슐화 위반이다. 
- 예시로 든 Rectangle Class에서도 알 수 있듯이, 접근자와 수정자를 남발하는 것은 좋지 못하다. 
- 자신의 크기를 조절하는 로직을 Rectangle 스스로 할 수 있도록 자기 스스로를 책임질 수 있도록 만들었다.

### 스스로 자신의 데이터를 책임지는 객체 
- 상태와 행동을 객체라는 하나의 단위로 묶은 이유는 객체 스스로 자신의 상태를 처리할 수 있게하기 위해서다. 
- 객체는 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.
- 따라서 객체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?" 라는 질문은 다음과 같은 두개의 질문으로 분리할 수 있다.
  1) 이 객체가 어떤 데이터를 포함해야 하는가?
  2) 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가? 


### 데이터 중심 설계의 문제점
- 데이터 중심의 설계가 변경에 취약한 이유는 두 가지다. 
  1) 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다. 
  2) 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를고립시킨 채 오퍼레이션을 결졍한다. 
- 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.
- 중요한 것은 내부가 어떤 상태를 가지고 관리하는가 보다, 다른 객체와 협력하는 방법이다. 
- 데이터 중심 설계의 초점은 객체의 외부가 아닌 내부로 향한다. 
- 객체가 관리할 데이터 세부 정보를 먼저 결정하기에, 구현이 이미 결정된 상태에서 협력 방법을 고민하기 때문에 문제가 생길 수 밖에 없다. 
